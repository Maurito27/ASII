üìò DOCUMENTACI√ìN T√âCNICA: PROYECTO ASII
Versi√≥n del Sistema: V24 (Stable - Indagaci√≥n Progresiva) Fecha de Documentaci√≥n: 12 de Diciembre, 2025 Desarrollado para: Industrias De Pascale - Depto. de Sistemas
====================================================================================================================================================================================
1. RESUMEN EJECUTIVO DEL PROYECTO
1.1. Definici√≥n
ASII (Asistente de Soporte IT Inteligente) es un sistema de inteligencia artificial generativa dise√±ado para actuar como un Consultor T√©cnico Senior automatizado. Su funci√≥n principal es asistir al equipo de soporte y operativos en la resoluci√≥n de problemas t√©cnicos, configuraci√≥n de software (Softland, SQL, etc.) y procedimientos internos, utilizando la base de conocimiento de la empresa (Manuales PDF, Docs, TXT).

A diferencia de los sistemas RAG (Retrieval-Augmented Generation) tradicionales que simplemente buscan palabras clave, ASII V24 implementa una Arquitectura Cognitiva de 4 Fases: Detecci√≥n, Indagaci√≥n, Lectura Selectiva e Instrucci√≥n.

1.2. Capacidades Diferenciales (Core Features)
El sistema ha evolucionado para resolver problemas espec√≠ficos de la operaci√≥n diaria:

Indagaci√≥n Progresiva: El bot no lee documentos enteros ciegamente. Primero extrae el √≠ndice (TOC), lo presenta al usuario y pregunta: "¬øQu√© necesitas espec√≠ficamente?". Esto reduce alucinaciones y mejora la precisi√≥n.

Memoria Visual (Visi√≥n): El sistema es capaz de "ver" los manuales. Extrae im√°genes, diagramas y capturas de pantalla de los PDFs, crea un cat√°logo inteligente y las env√≠a al chat cuando la explicaci√≥n lo requiere.

Modo Instructor (Sherpa): Detecta si el usuario es novato (ej: dice "no s√©", "gu√≠ame"). En ese caso, abandona el tecnicismo y asume un rol pedag√≥gico, guiando paso a paso desde la introducci√≥n.

Auditor√≠a Financiera en Tiempo Real: Cuenta con un monitor de costos que calcula cada token consumido (Entrada/Salida) basado en tarifas de Gemini 2.0 Flash, con un Kill Switch autom√°tico si se supera el presupuesto.

Eficiencia de Cach√© H√≠brido: Utiliza un sistema de doble cach√© (Embeddings vectoriales para b√∫squeda + JSON estructurado para lectura profunda) que reduce los tiempos de respuesta y costos operativos a casi cero en consultas recurrentes.

1.3. Tecnolog√≠as Base

Motor Cognitivo: Google Gemini 2.0 Flash (v√≠a API).

Procesamiento Documental: PyMuPDF4LLM (Extracci√≥n de Markdown + Im√°genes).

Base de Datos Vectorial: ChromaDB (B√∫squeda sem√°ntica local).

Interfaz: Telegram Bot API (Async).

Lenguaje: Python 3.10+.



=============================================================================================================================================================================================

2. √çNDICE GENERAL DE LA DOCUMENTACI√ìN

CAP√çTULO 1: Visi√≥n General (Actual)
1.1. Resumen del Proyecto.

1.2. Capacidades Diferenciales.

1.3. Tecnolog√≠as Base.

CAP√çTULO 2: Arquitectura L√≥gica
2.1. El Flujo de los 4 Estados (Explorando -> Indagando -> Leyendo -> Instructor).

2.2. Diagrama de Flujo de Datos (Input -> Procesador -> Cerebro -> Output).

2.3. Sistema de Cach√© H√≠brido (Vectores vs. JSON).

CAP√çTULO 3: An√°lisis Detallado de C√≥digo (Core)
An√°lisis l√≠nea a l√≠nea de los componentes vitales:

3.1. brain.py: El orquestador de inteligencia y prompts din√°micos.

3.2. session_manager.py: La gesti√≥n de la memoria de corto plazo y estados.

3.3. document_processor.py: El motor de extracci√≥n de texto, √≠ndices e im√°genes.

CAP√çTULO 4: Subsistema de Visi√≥n y Recursos
4.1. Estrategia de Cat√°logo de Im√°genes (C√≥mo el bot "sabe" qu√© fotos tiene).

4.2. Detecci√≥n de Referencias (Algoritmo de coincidencia difusa/fuzzy).

4.3. cache_manager.py: Estructura de guardado en disco.

CAP√çTULO 5: Motor de B√∫squeda y RAG
5.1. rag_engine.py: L√≥gica de "Francotirador" (B√∫squeda exacta) vs. "Explorador" (Sem√°ntica).

5.2. Ingesta de datos (ingest_script.py).

CAP√çTULO 6: Interfaz y Control
6.1. telegram_bot.py: Manejo de mensajes largos (paginaci√≥n anti-crash) y UX.

6.2. Comandos T√°cticos (/manual, /limpiar, /costos).

CAP√çTULO 7: Finanzas y Operaciones
7.1. monitor_dashboard.py: El panel de control de costos.

7.2. Sistema de Logs y Kill Switch (API_LOCKED).

7.3. Despliegue y Mantenimiento (run_bot.bat).








üìò CAP√çTULO 2: ARQUITECTURA L√ìGICA
El n√∫cleo de ASII V24 no es un simple modelo de "Pregunta-Respuesta", sino un Sistema de Estados Cognitivos. El bot cambia su comportamiento y sus herramientas seg√∫n la etapa de la conversaci√≥n en la que se encuentre con el usuario.

2.1. EL FLUJO DE LOS 4 ESTADOS
El archivo session_manager.py gobierna la "memoria de corto plazo" del bot, definiendo en qu√© estado mental se encuentra para cada usuario (identificado por chat_id).

1Ô∏è‚É£ Estado: EXPLORANDO (Default)
Es el estado inicial y de "reposo". El bot act√∫a como un bibliotecario generalista.

Objetivo: Encontrar d√≥nde est√° la informaci√≥n.

Herramientas Activas:

Motor RAG (Vectorial): Busca fragmentos sueltos en toda la base de conocimientos.

Francotirador (Regex): Busca coincidencias exactas en nombres de archivos (ej: "manual sql").

B√∫squeda Web: Si no hay data interna, consulta DuckDuckGo.

Transici√≥n: Si detecta un archivo espec√≠fico con alta probabilidad, pasa a INDAGANDO.

2Ô∏è‚É£ Estado: INDAGANDO (Diagn√≥stico)
Es el estado de "Triaje". El bot ha encontrado un manual candidato pero NO lo lee completo todav√≠a para ahorrar recursos y evitar alucinaciones.

Acci√≥n T√©cnica: Llama a procesador.extraer_indice_ligero(ruta_pdf).

Interacci√≥n:

Presenta el √çndice (Tabla de Contenidos) al usuario.

Pregunta: "¬øQu√© tema espec√≠fico necesitas de este manual?".

Por qu√© existe: Evita que el bot responda con informaci√≥n de la p√°gina 50 cuando el usuario necesitaba la p√°gina 2.

Transici√≥n: Cuando el usuario responde (con un tema o pidiendo gu√≠a), pasa a LEYENDO.

3Ô∏è‚É£ Estado: LEYENDO (Lectura Profunda)
El bot "abre el libro". Carga el contenido completo en su memoria de contexto.

Acci√≥n T√©cnica: Llama a procesador.procesar_pdf(ruta_pdf) (o recupera del Cach√© JSON).

Capacidades Activas:

Visi√≥n: Accede al Cat√°logo de Im√°genes.

Citas: Puede referenciar p√°ginas exactas.

Comportamiento: Responde preguntas espec√≠ficas sobre el documento activo.

Transici√≥n: Se mantiene aqu√≠ hasta que el usuario diga "salir", "cancelar" o "basta".

4Ô∏è‚É£ Modo: INSTRUCTOR (Comportamiento L√≥gico)
Nota: No es un estado duro en el c√≥digo, sino una adaptaci√≥n del Prompt en el estado LEYENDO.

Trigger: Detectado por el LLM cuando el usuario dice "no s√©", "gu√≠ame", "soy nuevo".

Cambio de Estrategia:

Ignora la b√∫squeda de soluciones r√°pidas.

Adopta una estructura pedag√≥gica: Concepto -> Prerrequisito -> Paso 1.

Sugiere el orden de lectura (ej: "Empecemos por la Introducci√≥n").

2.2. DIAGRAMA DE FLUJO DE DATOS (Pipeline)
El dato viaja a trav√©s de una tuber√≠a de procesamiento dise√±ada para maximizar la velocidad y minimizar el costo.

Fragmento de c√≥digo

graph TD
    A[Usuario (Telegram)] -->|Mensaje/Foto| B(telegram_bot.py)
    B -->|Consulta + SessionID| C{session_manager.py}
    
    C -- Estado: EXPLORANDO --> D[brain.py (RAG Engine)]
    D -->|B√∫squeda Vectorial| E[(ChromaDB)]
    D -->|B√∫squeda Web| F[DuckDuckGo]
    
    C -- Estado: INDAGANDO --> G[document_processor.py]
    G -->|Extraer Solo √çndice| H(Lectura Ligera PyMuPDF)
    
    C -- Estado: LEYENDO --> I[brain.py (Modo Experto)]
    I -->|Verificar Cach√©| J{cache_manager.py}
    
    J -- No Existe --> K[Procesador Full]
    K -->|OCR + Extracci√≥n| L[Markdown + Im√°genes .jpg]
    K -->|Guardar| M[(Disco JSON + Images)]
    
    J -- S√≠ Existe --> M
    
    M -->|Contexto + Cat√°logo Visual| N[Gemini 2.0 Flash API]
    N -->|Respuesta + Referencias IMG| O[Generador de Respuesta]
    
    O -->|Texto Paginado + Fotos| A
Puntos Cr√≠ticos del Flujo:

Filtro de Seguridad (API_LOCKED): Antes de llamar a Gemini (N), brain.py verifica si existe el archivo de bloqueo por presupuesto.

Inyecci√≥n Visual: En el paso (N), el cat√°logo de im√°genes se inyecta como texto en el prompt del sistema para que Gemini "sepa" qu√© fotos existen.

2.3. SISTEMA DE CACH√â H√çBRIDO
ASII V24 utiliza dos tipos de memoria para equilibrar precisi√≥n y profundidad. Este es uno de los diferenciadores t√©cnicos m√°s fuertes del proyecto.

A. Cach√© Vectorial (B√∫squeda R√°pida)
Tecnolog√≠a: ChromaDB.

Ubicaci√≥n: data/chroma_db.

Contenido: El PDF se rompe en "chunks" (fragmentos) de 1000 caracteres. Se convierten a vectores matem√°ticos (embeddings).

Uso: Se usa SOLO en el estado EXPLORANDO para encontrar d√≥nde est√° la informaci√≥n.

Ventaja: Extremadamente r√°pido para b√∫squedas sem√°nticas ("c√≥mo facturar" encuentra "emisi√≥n de facturas").

Desventaja: Pierde el contexto global del documento (no sabe qu√© cap√≠tulo va antes de cu√°l).

B. Cach√© Estructurado (Lectura Profunda)
Tecnolog√≠a: Archivos JSON + Carpetas de Im√°genes.

Ubicaci√≥n: data/cache_docs y data/images_cache.

Contenido:

Texto completo del PDF convertido a Markdown limpio.

Mapa de navegaci√≥n (jerarqu√≠a de t√≠tulos #, ##, ###).

Cat√°logo Inteligente de Im√°genes: Lista de fotos con su descripci√≥n contextual y n√∫mero de p√°gina.

Uso: Se usa en los estados INDAGANDO y LEYENDO.

Ventaja: Mantiene la integridad total del manual. Permite al LLM entender "el todo" y ver im√°genes.

Costo: $0.00 leerlo del disco (evita re-procesar el PDF con CPU cada vez).






üìò CAP√çTULO 3: AN√ÅLISIS DETALLADO DE C√ìDIGO (CORE)
Este cap√≠tulo documenta la l√≥gica interna de los tres archivos Python que constituyen el "Sistema Nervioso Central" de ASII V24.

3.1. app/logic/brain.py (El Orquestador)
Es el archivo principal donde reside la toma de decisiones. Coordina la memoria, la visi√≥n, el control de costos y la generaci√≥n de respuestas.

A. Control Financiero y Seguridad
Antes de procesar cualquier pensamiento, el cerebro verifica si tiene permiso para gastar dinero.

verificar_kill_switch(): Revisa si existe el archivo data/API_LOCKED. Si existe, aborta inmediatamente devolviendo "SISTEMA PAUSADO". Esto act√∫a como un fusible f√≠sico de seguridad.

auditar_costos(respuesta_llm):

Input: Recibe el objeto usage_metadata de la respuesta de Gemini.

Proceso: Multiplica los tokens de entrada por $0.10/1M y salida por $0.40/1M.

Output: Escribe una l√≠nea en el CSV usage_log.csv y muestra el costo en consola. Es vital para la auditor√≠a.

B. Sistema de Visi√≥n (L√≥gica Difusa)
detectar_imagenes_mencionadas(texto, catalogo):

Esta funci√≥n resuelve el problema de "hallar la foto correcta".

No busca solo coincidencias exactas. Utiliza 3 estrategias:

Exacta: Si el LLM dice img-01.jpg.

Parcial: Si el LLM dice img-01 (sin extensi√≥n).

Contextual: Si el LLM dice "la imagen de la p√°gina 5" (busca en el cat√°logo qu√© foto est√° en esa p√°gina).

Retorno: Una lista de rutas de archivos .jpg lista para enviar a Telegram.

C. El Bucle Principal: generar_respuesta_inteligente
Esta funci√≥n as√≠ncrona es el coraz√≥n del sistema. Implementa la m√°quina de estados:

Bloque de Transici√≥n (Fase Indagaci√≥n -> Lectura):

Si el estado anterior era INDAGANDO, asume que el texto que acaba de entrar es la selecci√≥n del usuario (ej: "Quiero ver Prerrequisitos").

Fuerza el cambio de estado a LEYENDO inmediatamente para procesar esa solicitud.

Bloque de Lectura Profunda (Fase 4):

Validaci√≥n: Verifica si el archivo f√≠sico a√∫n existe.

Procesamiento: Llama al cach√©. Si no existe, invoca al procesador pesado.

Inyecci√≥n de Prompt (V24 - "Sherpa"): Aqu√≠ se carga el prompt din√°mico que instruye a Gemini a actuar como "Instructor" si el usuario parece perdido ("gu√≠ame") o como "T√©cnico" si es espec√≠fico.

Inyecci√≥n Visual: Inserta la lista de im√°genes disponibles (catalogo) en el prompt del sistema.

Bloque de Detecci√≥n (Fase 1):

Usa detectar_archivo_francotirador (Regex).

Diferencial V24: Si encuentra un archivo, NO LO CARGA. Llama a procesador.extraer_indice_ligero para obtener solo el texto del √≠ndice y cambia el estado a INDAGANDO.

3.2. app/logic/session_manager.py (Gestor de Estados)
Este m√≥dulo maneja la memoria RAM de "qui√©n es qui√©n" y "en qu√© est√°" cada usuario.

Estructura de Datos
Utiliza un diccionario en memoria _sesiones:

Python

{
    "chat_id_123": {
        "estado": "INDAGANDO",       # El estado mental actual
        "doc_activo": "Manual.pdf",  # El archivo que est√° mirando
        "metadata": {...},           # Datos t√©cnicos del archivo
        "consulta_inicial": "error"  # Qu√© pregunt√≥ el usuario al principio
    }
}
Estados Definidos
EXPLORANDO: Estado por defecto. El bot busca en toda la base de datos.

INDAGANDO: Estado de espera. El bot mostr√≥ un √≠ndice y espera que el usuario elija. (Introducido en V23).

LEYENDO: Estado de foco. El bot tiene cargado el contexto completo de un documento y responde sobre √©l.

Funciones Clave
cambiar_estado(...): La √∫nica forma segura de transicionar. Se encarga de limpiar o persistir datos seg√∫n la transici√≥n.

limpiar_sesion(...): El bot√≥n de p√°nico. Borra todo y devuelve al usuario al estado EXPLORANDO.

3.3. app/logic/document_processor.py (El Ojo del Sistema)
Es el encargado de transformar PDFs binarios en datos que la IA pueda entender.

A. extraer_indice_ligero(ruta_pdf) (La V√≠a R√°pida)
Tecnolog√≠a: Usa fitz (PyMuPDF) en modo bajo nivel.

L√≥gica: Solo lee la tabla de metadatos (TOC) del PDF.

Velocidad: < 0.5 segundos.

Uso: Se ejecuta en la Fase 1 para mostrar el men√∫ al usuario sin gastar CPU en procesar todo el texto.

B. procesar_pdf(ruta_pdf) (La V√≠a Lenta/Completa)
Tecnolog√≠a: Usa pymupdf4llm.

L√≥gica:

Convierte cada p√°gina a Markdown.

Extracci√≥n de Im√°genes: Recorta cada gr√°fico y lo guarda en data/images_cache/Nombre_Manual/.

Inserta referencias ![](...) en el texto Markdown.

Salida: Un diccionario complejo con el texto completo, el mapa de navegaci√≥n y el cat√°logo de im√°genes.

C. _crear_catalogo_imagenes(...)
Esta funci√≥n crea la "Inteligencia Visual".

Recorre el Markdown generado.

Cada vez que encuentra una etiqueta de imagen, mira qu√© texto hay 150 caracteres antes.

Guarda ese texto como "Contexto" en el cat√°logo.

Resultado: El bot sabe que img-5.jpg aparece justo despu√©s del texto "Configuraci√≥n de Puertos", permiti√©ndole asociar la imagen al tema.



üìò CAP√çTULO 4: SUBSISTEMA DE VISI√ìN Y RECURSOS
ASII V24 no utiliza modelos de visi√≥n costosos (como GPT-4 Vision) para analizar im√°genes en tiempo real. En su lugar, utiliza una Estrategia de Asociaci√≥n Contextual que permite al bot "saber" qu√© contiene una imagen bas√°ndose en el texto que la rodea en el manual original.

4.1. ESTRATEGIA DE CAT√ÅLOGO DE IM√ÅGENES (Visual Indexing)
El problema fundamental de los PDFs t√©cnicos es que las im√°genes est√°n incrustadas como objetos binarios sin significado sem√°ntico.

El Proceso de Catalogaci√≥n
Cuando document_processor.py analiza un PDF en la Fase de Lectura Profunda (LEYENDO), realiza los siguientes pasos para construir la "Visi√≥n" del bot:

Extracci√≥n F√≠sica: Usa PyMuPDF para recortar cada objeto de imagen y guardarlo como .jpg en data/images_cache/{Nombre_Manual}/.

Mapeo de Posici√≥n: Identifica en qu√© byte del texto original aparec√≠a la imagen.

Captura de Contexto (La Clave):

El sistema retrocede 150 caracteres desde la posici√≥n de la imagen.

Captura ese texto (ej: "Para configurar el puerto, ver la siguiente pantalla:").

Asocia ese texto a la imagen img-3.jpg.

Estructura del Cat√°logo (JSON)
Esta informaci√≥n se guarda en el archivo de cach√© del documento:

JSON

"catalogo_imagenes": [
    {
        "archivo": "img-0.jpg",
        "ruta_completa": "data/images_cache/Manual_SQL/img-0.jpg",
        "pagina": 3,
        "contexto": "Figura 1: Pantalla de inicio de sesi√≥n del servidor SQL."
    },
    {
        "archivo": "img-1.jpg",
        "ruta_completa": "data/images_cache/Manual_SQL/img-1.jpg",
        "pagina": 5,
        "contexto": "Seleccione la opci√≥n 'Mixed Mode' como se muestra abajo:"
    }
]
4.2. DETECCI√ìN DE REFERENCIAS (Algoritmo de Coincidencia)
Una vez que el LLM (Gemini) tiene el cat√°logo inyectado en su prompt, puede mencionar im√°genes. Sin embargo, los LLMs son imprecisos (pueden decir "ver imagen 1", "ver img-1.jpg" o "la foto de la p√°gina 3").

Para resolver esto, brain.py utiliza la funci√≥n detectar_imagenes_mencionadas, que aplica una L√≥gica de Triple Criterio:

Coincidencia Exacta (High Confidence):

Busca si el string img-0.jpg aparece tal cual en la respuesta.

Uso: Cuando el LLM sigue la instrucci√≥n al pie de la letra.

Coincidencia Parcial (Medium Confidence):

Busca si el nombre base img-0 aparece, ignorando la extensi√≥n.

Uso: Cuando el LLM olvida poner ".jpg".

Coincidencia Contextual (Fuzzy Logic):

Si el texto menciona "p√°gina X" y la palabra "imagen/figura/foto".

El algoritmo busca en el cat√°logo qu√© imagen corresponde a esa p√°gina X.

Uso: Cuando el LLM dice "Como se ve en la imagen de la p√°gina 5...".

4.3. app/logic/cache_manager.py (Gestor de Persistencia)
Este componente es el responsable de que el sistema sea econ√≥micamente viable. Evita que tengamos que pagar tokens o gastar CPU procesando el mismo manual dos veces.

Funciones Cr√≠ticas
Python

"""
Gestor de Cach√© (cache_manager.py)
----------------------------------
Responsabilidad: Guardar y recuperar el an√°lisis procesado (JSON) de los documentos.
"""
import os
import json
from app.core.config import Configuracion

class CacheManager:
    def __init__(self):
        self.cache_dir = os.path.join(Configuracion.DIRECTORIO_BASE, "data", "cache_docs")
        if not os.path.exists(self.cache_dir):
            os.makedirs(self.cache_dir)

    def _obtener_ruta_hash(self, ruta_fisica_pdf):
        """Genera un ID √∫nico basado en el nombre del archivo para el JSON de cach√©."""
        nombre_base = os.path.basename(ruta_fisica_pdf)
        return os.path.join(self.cache_dir, f"{nombre_base}.json")

    def guardar_en_cache(self, ruta_fisica_pdf, datos_analisis):
        """
        Guarda el diccionario complejo (Texto + Cat√°logo + Mapa) en disco.
        """
        ruta_json = self._obtener_ruta_hash(ruta_fisica_pdf)
        try:
            with open(ruta_json, 'w', encoding='utf-8') as f:
                json.dump(datos_analisis, f, ensure_ascii=False, indent=2)
            print(f">> [Cach√©] SAVE: An√°lisis guardado en {ruta_json}")
        except Exception as e:
            print(f">> [Cach√©] ERROR guardando: {e}")

    def obtener_analisis_cacheado(self, ruta_fisica_pdf):
        """
        Intenta recuperar el an√°lisis previo. Retorna None si no existe o es viejo.
        """
        ruta_json = self._obtener_ruta_hash(ruta_fisica_pdf)
        
        if not os.path.exists(ruta_json):
            print(f">> [Cach√©] MISS: El documento no est√° procesado ({os.path.basename(ruta_fisica_pdf)})")
            return None
            
        try:
            with open(ruta_json, 'r', encoding='utf-8') as f:
                datos = json.load(f)
            print(f">> [Cach√©] HIT: Documento recuperado de disco.")
            return datos
        except Exception:
            return None

gestor_cache = CacheManager()
Flujo de Vida del Dato
D√≠a 1: Usuario pide "Manual SQL". cache_manager retorna None. document_processor trabaja (tarda 5s). cache_manager guarda el JSON.

D√≠a 2: Usuario pide "Manual SQL". cache_manager encuentra el JSON. Carga inmediata (0.1s). Costo de procesamiento CPU = 0.




üìò CAP√çTULO 5: MOTOR DE B√öSQUEDA Y RAGEl subsistema de b√∫squeda es la puerta de entrada al flujo de trabajo de ASII. Antes de poder leer o indagar, el bot debe localizar el archivo correcto entre cientos de manuales. Para ello, implementa una Estrategia Dual que prioriza la velocidad sobre la complejidad.5.1. app/logic/rag_engine.py (El Localizador)Este archivo contiene la l√≥gica para recuperar informaci√≥n. No "piensa" (eso lo hace el cerebro), solo "busca".A. Estrategia 1: "El Francotirador" (B√∫squeda Heur√≠stica)Es la primera l√≠nea de defensa. Si el usuario sabe lo que quiere, no perdemos tiempo con vectores matem√°ticos.Funci√≥n: detectar_archivo_francotirador(mensaje)L√≥gica:Escanea la carpeta data/raw_docs en busca de nombres de archivos reales.Normaliza el mensaje del usuario (min√∫sculas, sin tildes).Busca coincidencias directas de palabras clave fuertes.Ejemplo:Usuario: "Necesito el manual de Validaciones".Archivo: SAR_PROD_MAN_Administrador_de_Validaciones.pdf.Resultado: Match positivo.Ventaja: Precisi√≥n del 100% y latencia casi nula.Impacto en V24: Si esta funci√≥n tiene √©xito, dispara inmediatamente el estado INDAGANDO (mostrando el √≠ndice), salt√°ndose la b√∫squeda sem√°ntica.B. Estrategia 2: "El Explorador" (B√∫squeda Sem√°ntica/RAG)Si el francotirador falla (ej: el usuario pregunta "c√≥mo arreglo el error 504" sin mencionar ning√∫n manual), se activa el motor RAG (Retrieval-Augmented Generation).Funci√≥n: buscar_contexto_relevante(query)Tecnolog√≠a: ChromaDB + HuggingFace Embeddings.Proceso:Convierte la pregunta del usuario en un vector num√©rico (lista de 384 n√∫meros flotantes).Compara ese vector con los millones de vectores almacenados en la base de datos chroma_db.Recupera los 4 fragmentos ("chunks") de texto que est√°n m√°s "cerca" matem√°ticamente.Salida: Retorna p√°rrafos sueltos de texto que contienen la posible respuesta.C. Gesti√≥n de MetadatosFunci√≥n: obtener_metadata_archivo(nombre_parcial)Responsabilidad: Dado un nombre de archivo (o parte de √©l), devuelve su "DNI":Ruta f√≠sica completa (C:\...\data\raw_docs\Sistemas\Manual.pdf).Categor√≠a (carpeta donde est√°).Tama√±o en KB.Cantidad aproximada de p√°ginas.5.2. data/ingest_script.py (La Digesti√≥n de Datos)Este script no se ejecuta con el bot. Es un proceso offline (mantenimiento) que el administrador corre cuando agrega nuevos manuales (/recargar o manualmente).Su trabajo es transformar documentos legibles por humanos en una base de datos vectorial legible por m√°quinas.Flujo de Ingesta (Paso a Paso):Carga (Loaders):Usa PyPDFLoader para leer PDFs p√°gina por p√°gina.Usa TextLoader para archivos .txt.Fragmentaci√≥n (Splitting):Los manuales son muy largos para entrar en un solo vector.Herramienta: RecursiveCharacterTextSplitter.Configuraci√≥n:chunk_size=1000: Corta el texto cada 1000 caracteres.chunk_overlap=200: Deja un solapamiento de 200 caracteres entre cortes para no romper frases a la mitad.Vectorizaci√≥n (Embedding):Convierte cada fragmento de texto en n√∫meros.Modelo: sentence-transformers/all-MiniLM-L6-v2 (Local y r√°pido).Nota: Este modelo "entiende" el significado. Sabe que "coche" y "autom√≥vil" son cercanos, aunque se escriban distinto.Almacenamiento (Persistencia):Guarda los vectores en data/chroma_db.Esta carpeta es la "Memoria de Largo Plazo" del bot.C√≥digo Cr√≠tico de Ingesta:Python# Fragmento de data/ingest_script.py

def ingest_docs():
    # 1. Definir el modelo de Embeddings (Cerebro sem√°ntico)
    embeddings = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
    
    # 2. Cargar documentos
    loader = DirectoryLoader(ruta_docs, glob="**/*.pdf", loader_cls=PyPDFLoader)
    raw_docs = loader.load()
    
    # 3. Cortar en pedacitos (Chunks)
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
    chunks = text_splitter.split_documents(raw_docs)
    
    # 4. Guardar en ChromaDB
    Chroma.from_documents(
        documents=chunks, 
        embedding=embeddings, 
        persist_directory="./data/chroma_db"
    )
    print("‚úÖ Ingesta completada. Cerebro actualizado.")
5.3. Diferencia entre Ingesta y ProcesamientoEs vital distinguir estos dos conceptos en ASII V24:Caracter√≠sticaIngesta (ingest_script.py)Procesamiento (document_processor.py)Cu√°ndo ocurreAntes de encender el bot (Mantenimiento).En tiempo real (cuando el usuario pide un doc).ObjetivoB√∫squeda y descubrimiento.Lectura profunda y comprensi√≥n.T√©cnicaVectores (Embeddings).Texto Plano (Markdown) + Im√°genes.OutputBase de datos chroma_db.Archivos JSON en cache_docs.Uso en BotEstado EXPLORANDO.Estados INDAGANDO y LEYENDO.




üìò CAP√çTULO 6: INTERFAZ Y CONTROLEl archivo app/interfaces/telegram_bot.py es la √∫nica capa del sistema que tiene contacto con el mundo exterior. Su responsabilidad es traducir las intenciones del usuario en √≥rdenes para el cerebro (brain.py) y renderizar las respuestas complejas (texto, botones, im√°genes, archivos) de una manera limpia y estable.6.1. telegram_bot.py (El Front-End)A diferencia de un script de bot b√°sico, la interfaz de ASII V24 implementa l√≥gica defensiva avanzada para evitar bloqueos y mejorar la experiencia de usuario (UX).A. Sistema Anti-Crash (Paginaci√≥n Autom√°tica)Telegram impone un l√≠mite estricto de 4096 caracteres por mensaje. En el "Modo Experto" o "Instructor", las respuestas de Gemini suelen superar este l√≠mite (ej: un procedimiento de 50 pasos). Si intentamos enviar el texto de una sola vez, la API devuelve un error Bad Request: message is too long y el bot muere.Para solucionar esto, implementamos la funci√≥n enviar_mensaje_seguro(...):L√≥gica de Fragmentaci√≥n:Verifica la longitud del texto.Si len(texto) > 4000:Busca el √∫ltimo salto de l√≠nea (\n) antes del car√°cter 4000 para no cortar una palabra a la mitad.Corta el mensaje en ese punto.Env√≠a el fragmento.Repite el proceso con el resto del texto.A√±ade encabezados visuales como *(...Parte 2)* para mantener el hilo.Manejo de Botones: Solo adjunta los botones interactivos (InlineKeyboard) al √∫ltimo fragmento del mensaje para no confundir al usuario.B. Renderizado de Elementos MultimediaASII V24 es multimodal. La interfaz maneja tres tipos de objetos que el cerebro puede devolver en su diccionario de respuesta:Texto (paquete["texto"]): Se env√≠a usando Markdown (negritas, listas, c√≥digo).Defensa: Si el Markdown est√° mal formado (ej: un asterisco sin cerrar), captura la excepci√≥n y env√≠a el texto plano para evitar el crash.Im√°genes (paquete["imagenes"]):El cerebro devuelve una lista de rutas locales (data/images_cache/.../img1.jpg).El bot itera sobre esta lista y usa context.bot.send_photo con la acci√≥n visual upload_photo (para que aparezca "subiendo foto..." en el chat).Archivos (paquete["archivos"]):Genera un ID √önico Temporal (dl_a1b2c3d4) para cada archivo y lo guarda en DOWNLOAD_CACHE en memoria RAM.Crea un bot√≥n "üì• Bajar Archivo" asociado a ese ID.Esto evita enviar la ruta del archivo en el callback de Telegram (que tiene l√≠mite de 64 bytes).C. Gesti√≥n de Callbacks (Botones)La funci√≥n manejar_callback es el controlador de eventos de la interfaz t√°ctil.confirmar_experto: Trigger que cambia el estado de INDAGANDO a LEYENDO en el session_manager.cancelar_experto: Trigger que limpia la sesi√≥n.dl_{uuid}: Trigger de descarga. Busca la ruta real en el diccionario DOWNLOAD_CACHE y env√≠a el documento f√≠sico.6.2. COMANDOS T√ÅCTICOSPara la administraci√≥n y uso avanzado, ASII V24 dispone de un set de comandos directos que ejecutan l√≥gica pura (Python) sin pasar por el LLM (ahorrando costos y tiempo).üë§ Comandos de Usuario (Operativos)ComandoFunci√≥nDescripci√≥n T√©cnica/startBienvenidaVerifica permisos de usuario (config.py) e inicia el saludo./limpiarResetLlama a gestor_sesiones.limpiar_sesion(chat_id). Borra el contexto de la conversaci√≥n actual. √ötil si el bot se queda "enganchado" con un tema anterior./manual [tema]B√∫squeda R√°pidaBypass del chat. Ejecuta directamente detectar_archivo_francotirador. Si encuentra algo, muestra el √≠ndice inmediatamente (Estado INDAGANDO)./ayudaGu√≠aMuestra la lista de comandos disponibles.üõ†Ô∏è Comandos de Administrador (Mantenimiento)ComandoFunci√≥nDescripci√≥n T√©cnica/statusMonitorMuestra el estado actual del session_manager (¬øEn qu√© fase est√°? ¬øQu√© archivo lee?) y el Uptime del servidor./costosAuditor√≠aLee el archivo data/usage_log.csv, filtra las l√≠neas con la fecha de hoy, suma la columna "CostoUSD" y reporta el gasto diario acumulado en tiempo real./inventarioExploraci√≥nEscanea recursivamente la carpeta data/raw_docs y devuelve un conteo de archivos por categor√≠a (subcarpetas)./recargarIngestaEjecuta el subproceso ingest_script.py para re-indexar la base vectorial (ChromaDB). √ötil cuando se agregan PDFs nuevos a la carpeta./flushLimpieza ProfundaComando Peligroso. Borra el contenido de data/cache_docs. Obliga al bot a re-procesar (y re-extraer im√°genes) de cualquier documento en la siguiente consulta.6.3. SEGURIDAD DE ACCESOEl bot implementa una capa de seguridad b√°sica en la funci√≥n verificar_acceso(update).Lista Blanca: Verifica si el user_id de Telegram est√° en la lista USUARIOS_PERMITIDOS definida en .env o config.py.Grupos: Si el bot se a√±ade a un grupo, solo responder√° si es mencionado expl√≠citamente (@AsiiBot ayuda) o si se responde a un mensaje suyo.Bloqueo: Si un usuario no autorizado intenta hablarle, el bot responde "‚õî Acceso Denegado" y no procesa la solicitud (ahorrando costos de IA).


üìò CAP√çTULO 7: FINANZAS Y OPERACIONESASII V24 integra un m√≥dulo financiero nativo ("FinOps") que audita cada token consumido. Esto permite descentralizar el uso de la IA sin riesgo de sorpresas en la facturaci√≥n de Google Cloud.7.1. SISTEMA DE AUDITOR√çA EN TIEMPO REALLa arquitectura no espera a fin de mes para saber cu√°nto gast√≥. Cada interacci√≥n se calcula y registra al instante.A. Precios Base (Gemini 2.0 Flash)El sistema est√° calibrado con las tarifas oficiales de la API (Confirmed Pricing):Input (Lectura): $0.10 USD por 1 mill√≥n de tokens.Output (Escritura): $0.40 USD por 1 mill√≥n de tokens.B. El Registro Maestro (usage_log.csv)Ubicaci√≥n: data/usage_log.csv.Cada vez que brain.py completa una generaci√≥n, la funci√≥n auditar_costos escribe una l√≠nea en este archivo con la siguiente estructura:TimestampFechaInput (Tokens)Output (Tokens)CostoUSD2025-12-12 10:00:012025-12-12154203500.001682Este archivo es la "Fuente de la Verdad" para todos los reportes y controles.7.2. DASHBOARD DE CONTROL (monitor_dashboard.py)ASII V24 incluye una aplicaci√≥n de consola independiente para el administrador del sistema. No es necesario entrar a la plataforma de Google para ver el consumo.Funcionalidades del MonitorVisualizaci√≥n en Vivo: Lee el CSV cada segundo y muestra el acumulado del mes.Proyecci√≥n de Presupuesto: Compara el gasto actual contra el LIMITE_PRESUPUESTO (ej: $50.00 USD).Control Manual: Permite detener el bot remotamente presionando la tecla 1.Mecanismo de "Kill Switch" (Corte de Emergencia)El sistema implementa un mecanismo de seguridad f√≠sica basado en archivos para detener el consumo de API inmediatamente.Activaci√≥n Autom√°tica: Si monitor_dashboard.py detecta que Gasto > Presupuesto, crea un archivo vac√≠o llamado API_LOCKED en la carpeta data/.Activaci√≥n Manual: Si el admin presiona 1 en el dashboard, se crea el mismo archivo.Efecto en el Cerebro:Antes de procesar cualquier mensaje, brain.py verifica: if os.path.exists(FILE_LOCK).Si el archivo existe, el bot responde al usuario: "‚õî SISTEMA PAUSADO".Costo: $0.00 (ni siquiera llama a la API).7.3. DESPLIEGUE Y MANTENIMIENTO OPERATIVOA. Estructura de Carpetas en Producci√≥nPara que el sistema funcione, la estructura de directorios debe mantenerse as√≠:PlaintextASII_V24/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ core/ (config.py)
‚îÇ   ‚îú‚îÄ‚îÄ logic/ (brain, processor, session, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/ (telegram_bot)
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ raw_docs/       <-- Aqu√≠ se tiran los PDF nuevos
‚îÇ   ‚îú‚îÄ‚îÄ chroma_db/      <-- Memoria Vectorial (B√∫squeda)
‚îÇ   ‚îú‚îÄ‚îÄ cache_docs/     <-- Memoria JSON (Lectura Profunda)
‚îÇ   ‚îú‚îÄ‚îÄ images_cache/   <-- Cat√°logo de Fotos Extra√≠das
‚îÇ   ‚îî‚îÄ‚îÄ usage_log.csv   <-- Auditor√≠a
‚îú‚îÄ‚îÄ .env                <-- API Keys y Tokens
‚îú‚îÄ‚îÄ run_bot.bat         <-- Inicia el Servidor (Bot)
‚îú‚îÄ‚îÄ monitor.bat         <-- Inicia el Panel de Control
‚îî‚îÄ‚îÄ requirements.txt
B. Procedimiento de Actualizaci√≥n de Manuales (Ingesta)Cuando el departamento de IT genera un nuevo procedimiento (ej: "Nuevo Servidor VPN.pdf"):Carga: Copiar el archivo PDF en la carpeta data/raw_docs (o cualquiera de sus subcarpetas).Indexaci√≥n:Opci√≥n A (Admin): Ejecutar el comando /recargar en el chat de Telegram.Opci√≥n B (Consola): Ejecutar python data/ingest_script.py.Resultado: El archivo se agrega a la base vectorial (chroma_db).Lectura: La primera vez que alguien lo pida, el bot tardar√° unos segundos en generar el cach√© JSON y extraer las im√°genes. Las siguientes veces ser√° instant√°neo.C. Mantenimiento de Cach√©Si un manual existente se actualiza (mismo nombre, contenido nuevo):Reemplazar el archivo en raw_docs.Ejecutar comando /flush en Telegram (o borrar data/cache_docs manualmente).Esto obliga al bot a re-procesar el archivo y actualizar su "visi√≥n" del contenido.